# Chapter 1. 웹 브라우저

## 1장 흐름

### `웹 브라우저가 메시지를 만든다.`

## 키워드

브라우저, 웹 서버, URL, HTTP, HTML, 프로토콜, URI, 리퀘스트 메시지, 리졸버, Socket 라이브러리, DNS 서버, 도메인 명

[ARP](https://www.notion.so/ARP-eb8aa69dfe8b4918ac92d7052ad9201d)

# Story 1.  HTTP 리퀘스트 메시지를 작성한다.

### URI에 대해 설명해 주세요.

클라이언트가 서버를 향해 요청메시지를 보낼때 요청 메시지 안에는 무엇을, 어떻게 내용이 있는데

여기서 무엇에 해당하는것이 `URI`

어떻게에 해당하는 것이 GET, POST등의 `메소드` 입니다.

![image](https://user-images.githubusercontent.com/64322765/224308938-ef7f821a-247b-4a81-84b5-5ef0321a747a.png)

URL은 인터넷 상에서 리소스의 위치를 식별하는 문자열, 

URN은 인터넷 상의 리소스의 이름을 식별하는 문자열, 

URI는 인터넷 상의 리소스를 식별하는 일반적인 용어이다.

### http://www.sapmple.co.kr, http://www.sapmple.co.kr/, http://www.sample.co.kr/animal, http://www.sample.co.kr/animal/elephant.html 차이점에 대해 설명해 주세요.

[`sample.co.kr`](http://sample.co.kr)

서버에서 기본값으로 설정해던 index.html로 액세스 합니다.

[`sample.co.kr/`](http://sample.co.kr/)

 파일명을 생략한 경우로 서버가 기본적으로 설정한 파일을 액세스 합니다. 보통 index.html 또는 default.html 파일명을 기본적으로 설정 해둡니다.

[`sample.co.kr/animal`](http://samle.co.kr/animal)

브라우저는 animal을 파일이면 파일 폴더면 폴더로 봅니다.

`sample.co.kr/animal/elephant.html`

animal폴더에 있는 elephant.html 파일에 액세스합니다.

### HTTP메소드 GET과 POST의 동작과정을 설명해 주세요.

GET 매소드는 URI로 지정한 정보를 도출합니다.

POST 메소드는 클라이언크에서 서버로 데이터를 송신합니다. 보통 폼에 입력한 데이터를 송신 하는 경우에 사용합니다.

GET 방식:

1. 사용자가 웹 브라우저에서 URL을 입력하고 요청을 보냅니다.
2. 서버는 URL의 쿼리 문자열에서 요청된 데이터를 읽어옵니다.
3. 서버는 요청된 데이터에 대한 응답을 생성하고, 응답 헤더와 함께 클라이언트에게 응답합니다.
4. 클라이언트는 응답 데이터를 받아 화면에 표시합니다.

POST 방식:

1. 사용자가 웹 브라우저에서 URL을 입력하고 요청을 보냅니다.
2. 클라이언트는 HTTP 요청 메시지의 본문에 데이터를 추가하여 보냅니다.
3. 서버는 HTTP 요청 메시지의 본문에서 요청된 데이터를 읽어옵니다.
4. 서버는 요청된 데이터에 대한 응답을 생성하고, 응답 헤더와 함께 클라이언트에게 응답합니다.
5. 클라이언트는 응답 데이터를 받아 화면에 표시합니다.

GET메서드는 쿼리 문자열에 데이터가 있으므로 서버는 바로 응답 데이터를 줄 수 있지만

POST메서드는 리퀘스트 메시지 바디 부분에 데이터가 있으므로 서버에서 데이터를 따로 가공해주고 응답데이터를 줘야한다.

### html 데이터를 get으로 보낼때 와 post로 보낼때의 차이점을 설명해 주세요.

1. `전송 방식`
- GET 방식: URL의 쿼리 문자열(query string)에 데이터를 추가하여 보냅니다.
- POST 방식: HTTP 요청 메시지의 본문(body)에 데이터를 추가하여 보냅니다.
1. `데이터 길이`
- GET 방식: URL에 데이터가 노출되므로 데이터 길이에 제한이 있습니다. 일반적으로 2048자 이하로 제한됩니다.
- POST 방식: HTTP 요청 메시지의 본문에 데이터가 포함되므로 길이에 제한이 없습니다.
1. `보안`
- GET 방식: URL에 데이터가 노출되므로 보안에 취약합니다. 또한, 브라우저 기록에도 남아 보안상 취약점이 될 수 있습니다.
- POST 방식: HTTP 요청 메시지의 본문에 데이터가 포함되므로 상대적으로 보안에 강합니다. 브라우저 기록에도 남지 않습니다.
1. `캐싱`
- GET 방식: URL이 동일하면 브라우저나 프록시 서버 등에서 캐싱하여 다음 요청 시에는 빠르게 처리됩니다.
- POST 방식: HTTP 요청 메시지의 본문에 데이터가 포함되므로 캐싱할 수 없습니다.
1. `서버 처리`
- GET 방식: URL의 쿼리 문자열에 데이터가 있으므로 서버에서 쉽게 처리됩니다. 또한, 검색 결과와 같이 리소스를 가져오는 요청에 적합합니다.
- POST 방식: HTTP 요청 메시지의 본문에 데이터가 있으므로 서버에서 데이터를 추출하는 작업이 필요합니다. 또한, 서버에 데이터를 추가, 수정, 삭제하는 요청에 적합합니다.

즉, GET 방식은 데이터 길이가 짧고 보안이 취약하지만, URL을 통해 쉽게 데이터에 접근할 수 있으며, 서버에서 간단하게 처리할 수 있는 경우에 적합합니다. 

반면에 POST 방식은 데이터 길이가 길고 보안이 강하지만, 서버에서 데이터를 추출하는 작업이 필요하며, 서버에 데이터를 추가, 수정, 삭제하는 요청에 적합합니다.

### 요청할 때 보내는 데이터가 수천 바이트라면 http의 GET과 POST중 어떤 매소드를 사용하실 건가요?

get에서 보내는 데이터는 쿼리마라미터로 전송하므로 한계가 있어 최대 수백바이트 입니다.

필드에 입력하는 데이터가 수백 바이트를 초과할 경우에는 post 메시지를 사용합니다.

### HTTP 메소드 PUT과 DELETE

HTTP 메서드 PUT과 DELETE는 웹 서버에서 데이터를 업데이트하거나 삭제하는 데 사용됩니다.

PUT 메서드는 URI로 지정한 서버의 파일을 치환합니다. URI로 지정한 파일이 없는 경우에는 새로 파일을 작성합니다.

DELETE 메서드는 URI로 지정한 서버의 파일을 삭제합니다.

### 클라이언트는 서버에게 html코드와 이미지 1개 동영상 1개가 있는 파일을 요청 하려고 하는데 요청 메시지를 몇 번 호출 하나요?

리퀘스트 메시지에 쓰는 URI는 하나만 가능하므로, 복수의 파일을 읽을 때는 웹 서버에 별도의 요청 메시지를 보냅니다. ex) image.jpg, image2.jpeg 등

3번

### Etag에 대해 설명해 주세요.

---

# Story 2. 웹 서버의 IP주소를 DNS서버에서 조회한다.

### IP주소를 네트워크 번호와 호스트 번호로 나누는 이유에 대해 설명해 주세요.

1. **라우팅 결정을 위한 필요성**
IP 주소는 라우팅 결정을 위해 사용됩니다. 라우팅 결정은 목적지 IP 주소를 사용하여 패킷을 수신 호스트로 전달하는 프로세스입니다. IP 주소를 네트워크와 호스트 번호로 나누면 라우터는 목적지 IP 주소의 네트워크 ID를 식별하여 목적지 호스트가 어떤 네트워크에 속해 있는지 결정할 수 있습니다.
2. **IP 주소 부족 문제**
IP 주소는 유한한 자원이며, IPv4에서는 주소 공간이 고갈되는 문제가 있습니다. IP 주소를 네트워크와 호스트 번호로 나누면 호스트 수와 네트워크 수를 유연하게 할당할 수 있으므로 IP 주소의 효율성이 높아집니다.
3. **보안 문제**
IP 주소를 네트워크와 호스트 번호로 나누면 서로 다른 네트워크에서 호스트를 식별할 수 있으므로 네트워크 보안을 유지하기 위해 필수적입니다. 네트워크 보안을 유지하기 위해서는 호스트가 속한 네트워크에 대한 정보를 알고 있어야 하므로 IP 주소를 네트워크와 호스트 번호로 분리하여 사용합니다.

### IP주소를 나타낼 때 넷마스크가 필요한 이유를 설명해 주세요.

IP 주소 규칙은 네트워크 번호와 호스트 번호 두가지를 합쳐서 32비트로 표현하고, 8비트(1바이트)씩 점으로 구분하여 10진수로 표기합니다.

그러나 32비트인건 알지만 IP주소의 네트워크 번호와 호스트 번호를 구분할 수 없어서 넷마스크를 통해 구분합니다.

예를 들어, 1.2.3.4/255.255.255.0에서 `/`을 기준으로 앞에는 IP주소 본체, 뒤는 넷마스크 입니다. 

이진수로 나타내면 001.010.011.100/111.111.111.000 인데 

넷마스크에서 연속된 1인 부분이 네트워크 번호이고,

0인 부분은 호스트 번호입니다. (참고 앞에 0이 5개씩 더 있는데 생략함. → 8비트를 3비트로 표현)

연속된 1이라는 말에 주의하자.

넷마스크가 255.255.255.212는 32비트 이진수로 표현하면 11111111 11111111 11111111 11010100이 됩니다. 이 값에서 네트워크 부분은 처음 26비트이며, 호스트 부분은 마지막 6비트입니다.

### 호스트 번호 비트가 모두 0인 경우와 모두 1인 경우에 대해 설명해 주세요.

호스트 번호 부분의 비트값이 모두 0인 경우는 IP주소는 각각의 기기를 나타내는 것이 아니라 서브넷 자체를 나타냅니다.

호스트 번호 부분의 비트값이 모두 1이면 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트를 나타냅니다.

- 모두 0: `서브넷` 자체를 나타냄
- 모두 1: 서브넷에 있는 기기 전체에 패킷을 보내는 `브로드캐스트`를 나타냄

### 도메인명과 IP주소를 구분하여 사용하는 이유에 대해 설명해 주세요.

IP주소는 외우기 어렵기 때문에, URL에 서버의 이름을 입력합니다. 그러나 URL에 IP주소를 입력해서 웹에 접근할 수도 있습니다. (웹 서버가 가상 호스트 기능을 사용하고 있으면 IP 주소로 접근 할 수 없는 경우도 있음.)

그러면 DNS는 서버 이름을 IP주소로 변경하거나 또는 IP주소를 서버 이름으로 변경해 줍니다.

TCP/IP네트워크는 IP주소로 통신 상대를 지정하므로 IP주소를 모르면 메시지를 전달할 수 없습니다. 그러므로 OS에 메시지 송신을 요청할때는 IP주소를 보내줘야 합니다. 

### DNS 리졸버에 대해 설명해 주세요.

IP주소를 알기 위해서는 DNS서버에 조회 메시지를 보내고 거기에서 반송되는 응답 메시지를 받아야 합니다. 이것은 DNS서버에 대한 클라이언트로 동작한다고 말할 수 있는데, 이것을 DNS 리졸버 또는 리졸버라고 부릅니다.

리졸버의 실체는 Socket 라이브러리의 일부이며 C언어에서 `gethostbyname(”서버도메인명”)`을 호출해 IP주소를 호출한다음 http 요청 메시지와 함께 OS에 건네주어 송신을 요청합니다.

### DNS 리졸버 내부 동작과정을 설명해 주세요.

![image](https://user-images.githubusercontent.com/64322765/224309040-c103fd4b-7230-41e3-99cd-ca01bf1105b9.png)

우선 DNS 리졸버의 실체는 C언어의 소켓 라이브러리의 일부인 gethostbyname() 함수 입니다.

gethostbyname(도메인명)을 호출하면 os내부의 프로토콜 스택으로 도메인명을 전송합니다. 프로토콜 스택은 이 내용을 랜어댑터를 이용해 디지털신호를 빛 또는 전기신호로 바꿔 DNS 서버로 송신하면 DNS 서버는 그 도메인 주소의 IP 번호를 반송합니다.

프로코콜 스택이 DNS 서버로 데이터를 보내거나

DNS서버가 프로토콜 스택으로 데이터를 보낼때는 TCP프로토콜이 아니라 UDP 프로토콜을 이용합니다. 

리졸버에게 도메인명을 건네주면 리졸버는 DNS서버에 요청해 IP주소를 알아내서 애플리케이션에 IP주소를 건네준다.

### 왜 DNS 서버는 UDP 써?

1. 빠른 응답 속도
DNS 요청과 응답은 대부분 크기가 작고 간단한 정보를 주고 받습니다. UDP는 연결 설정과 연결 해제 과정이 없기 때문에 TCP(Transmission Control Protocol)보다 간단하고 빠른 속도로 통신할 수 있습니다. DNS 서버가 UDP를 사용하면 빠른 응답 속도를 보장할 수 있습니다.
2. 부담 감소
UDP는 연결 설정과 연결 해제 과정이 없기 때문에 상대적으로 TCP보다 부담이 적습니다. DNS 서버는 매우 많은 요청을 처리해야 합니다. 만약 TCP를 사용하면 연결 설정 및 해제 과정에서 오버헤드가 발생하여 부하가 증가할 수 있습니다. 따라서 UDP를 사용하면 DNS 서버의 부담을 줄일 수 있습니다.
3. 높은 신뢰성
UDP는 TCP와 달리 오류 검사 및 재전송 기능이 없습니다. 그러나 DNS 요청과 응답은 크기가 작고 간단한 정보이기 때문에 재전송 기능이 없어도 문제가 발생할 가능성이 적습니다. 또한, DNS 서버는 여러 대가 있어서 하나의 DNS 서버에서 응답이 실패하면 다른 DNS 서버에서 응답을 제공할 수 있습니다. 이러한 이유로 UDP를 사용하면 높은 신뢰성을 보장할 수 있습니다.

dns 서버는 수많은 요청을 해야 하는데 tcp인 경우 연결과 해제를 하므로 오버헤드가 크다. 그러나 udp는 연결과 해제과정이 없어서 간단하고  빠르다.

UDP는 TCP와 달리 오류 검사 및 재전송 기능이 없습니다. 그러나 DNS 요청과 응답은 크기가 작고 간단한 정보이기 때문에 재전송 기능이 없어도 문제가 발생할 가능성이 적습니다. 또한, DNS 서버는 여러 대가 있어서 하나의 DNS 서버에서 응답이 실패하면 다른 DNS 서버에서 응답을 제공할 수 있습니다. 

따라서, DNS 서버가 UDP를 사용하는 이유는 빠른 응답 속도, 부담 감소, 높은 신뢰성 등의 이유 때문입니다.

---

# Story 3. 전 세계의 DNS서버가 연대한다.

### DNS가 가지고 있는 세 가지 정보

DNS는 기본적으로 이름, 클래스, 타입을 가집니다.

**이름:** 서버나 메일 배송 목적지와 같은 이름

**클래스:** DNS의 구조를 고안했을때 인터넷 이외에도 다른 네트워크가 있어 구분하기 위해 사용 지금은 인터넷 밖에 없으므로 `IN`값만 사용.

**타입:** 이름에 어떤 타입의 정보가 지원되는지를 나타냅니다. 예를 들어, 타입이 A(Address)면 IP주소, 타입이 MX(Mail eXchange)면 메일 배송 목적지를 나타냅니다. 타입에 따라 클라이언트에 회답하는 정보 내용도 달라집니다.

![4A56980F-2303-4824-A292-F6BB18393BBA.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c01701d-7bde-454a-a83d-ac1bc208c57b/4A56980F-2303-4824-A292-F6BB18393BBA.jpeg)

liging@cyber.co.kr을 DNS서버에 요청하면

10 mail.cyber.co.kr과 192.0.2.227 두개를 반환함.

### DNS 서버에 IP주소를 등록하는 방법을 설명해 주세요.

www.lab.glasscom.com을 찾는다고 가정

우선 기본적으로 `.`을 기준으로 하나의 도메인 이라고 합니다. www, lab, glasscom, com 4개의 도메인

1. **각 도메인의 상위 DNS서버에 하위 DNS서버를 저장하는 방법**
2. 모든 **DNS 서버를 루트 도메인에 등록** 

여기서 루트 도메인이란 최상위 도메인 뒤에 . 하나가 더 붙은 www.lab.glasscom.com.형태입니다.

일반적으로 도메인 네임 시스템(DNS)은 분산 시스템으로 설계되어 있기 때문에, 도메인 이름의 각 부분에 해당하는 하위 DNS 서버가 있습니다. 예를 들어 **`www.lab.glasscom.com`**에서 **`com`** 도메인에 대한 DNS 서버를 찾은 후, 그 다음에 **`glasscom.com`**, **`lab.glasscom.com`**, **`www.lab.glasscom.com`**의 하위 DNS 서버를 차례로 찾아가는 방식입니다.

따라서, 일반적으로 도메인 네임 시스템은 각 도메인의 상위 DNS 서버에 하위 DNS 서버를 저장하는 방법을 사용합니다. 이 방법은 분산 시스템으로 설계된 DNS 시스템에서 이점을 가집니다. 

예를 들어, **`www.lab.glasscom.com`**의 경우, **`com`** 도메인의 상위 DNS 서버는 **`glasscom.com`** 도메인의 하위 DNS 서버의 IP 주소를 반환하고, **`glasscom.com`** 도메인의 상위 DNS 서버는 **`lab.glasscom.com`** 도메인의 하위 DNS 서버의 IP 주소를 반환하고, **`lab.glasscom.com`** 도메인의 하위 DNS 서버는 **`www.lab.glasscom.com`**의 IP 주소를 반환합니다.

따라서, 각 도메인의 상위 DNS 서버에 하위 DNS 서버를 저장하는 방법을 사용하며, 이를 통해 DNS 시스템이 분산되어 작동하고 단일 장애 지점 문제를 최소화할 수 있습니다.

모든 DNS 서버를 루트 도메인에 넣어버리면 하나의 서버 루트 도메인 서버가 너무 많은 리소스를 관리하므로 비효율적

### DNS 서버에서 IP 주소 가져오기

![image](https://user-images.githubusercontent.com/64322765/224309171-8079cb99-cc0a-4ee7-9a30-d87be055ca11.png)
### DNS 서버의 캐시 기능

최상위 루트 도메인에서부터 차례대로 따라가지 않고,

DNS 서버는 한 번 조사한 이름을 캐시에 기록해서, 캐시에 조회한 서버이름이 존재하면 바로 그 정보를 회답합니다.

하지만 캐시에 정보를 저장한 후 등록된 정보가 변경되는 경우가 있으므로 캐시 정보를 올바르다고 확신할 수 없습니다.

따라서 DNS 서버에 등록하는 정보에 유효 기한을 설정하고, 유효기간이 지나면 캐시에서 삭제합니다. 또한 조회에 응답할 때 캐시에 저장된 정보인지, 아니면 각 DNS 서버에서 응답했는지 알려줍니다.

---

# Story 4. 프로토콜 스택에 메시지 송신을 의뢰한다.

애플리케이션(서버)은 `디스크럽터`라는 번호표 같은 것으로 소켓을 식별합니다.

디스크럽터는 소켓을 만들도록 의뢰한 애플리케이션(서버)에게 건네주는 것.

- 디스크립터는 프로토콜 스택 내부에 있는 다수의 소켓을 구별 하기위해 나타내는 정보입니다.

접속 상대(클라이언트)에게 건네주는 것이 아니므로 접속 상대측에서는 디스크럽터 존재를 모름 → 그럼 클라이언트는 무슨 소켓인지 어떻게 알지? 

클라이언트는 `IP 주소`와 `포트 번호`을 통해 소켓을 식별합니다.

![image](https://user-images.githubusercontent.com/64322765/224309218-0b532d74-f8e4-4329-bf86-be7aee8a5596.png)

1. DNS서버를 통해 IP를 알아낸다.
2. 애플리케이션(서버)은 소켓을 만들고, 소켓을 나타내는 디스크립터를 애플리케이션에 알려줍니다. (디스크립터는 프로토콜 스택 내부에 있는 다수의 소켓을 구별 하기위해 나타내는 정보입니다.)
3. 클라이언트가 소켓에 IP주소와 포트번호를 통해 소켓에 연결한다.
4. 클라이언트는 소켓 수신버퍼에 요청 메시지를 작성한다.
5. 서버는 소켓(디스크럽터로 구별)의 요청 메시지를 수신한다.
6. 서버는 소켓을 닫고(소켓 사이를 연결한 파이프를 닫고, 소켓 말소), 클라이언트도 연결이 끊긴다.

이것이 HTTP의 본래 동작입니다.

HTTP프로토콜은 html 문서나 영상 데이터를 하나하나 별도로 취급해서 1개의 데이터를 읽을 때마다

1. **접속**
2. **요청 메시지 송신**
3. **응답 메시지 수딘**
4. **연결 끊기**

4가지의 동작을 반복했으나 너무 비효율적이라 

HTTP 1.1 버전부터는 `keep alive` 기능으로 한번 접속 후 연결을 끊지않고 복수의 요청과 복수의 수신을 합니다.

### 한대의 컴퓨터에서 똑같은 ip주소 똑같은 포트 번호를 가지고 똑같은 웹에 동시에 접속가능한 이유

서버는 각각의 사용자 마다 디스크럽터를 

### 문제

네트워크 애플리케이션은 네트워크를 직접 제어할 수 있나요?

애플리케이션은 자체에서 네트워크를 제어하는 것이 아니라 OS에 의뢰하여 네트워크를 제어합니다.즉 브라우저를 비롯한 네트워크 애플리케이션은 네트워크를 제어하는 기능이 없습니다.

---
