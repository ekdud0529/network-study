### 방화벽이 필요한 이유는 무엇인가요?

1. 네트워크 보안 강화
방화벽을 사용하면 내부 네트워크를 외부로부터 격리시켜, 외부에서 내부로의 불법적인 접근을 차단할 수 있습니다. 또한 내부 네트워크에서 발생하는 인터넷 트래픽도 모니터링하여 악성코드와 바이러스 등을 차단할 수 있습니다.
2. 데이터 보호 강화
방화벽을 사용하면 인터넷에서 내부 네트워크로의 데이터 유출을 방지할 수 있습니다. 방화벽은 인터넷으로부터 들어오는 트래픽을 모니터링하고, 내부 네트워크에서 인터넷으로 나가는 데이터를 검사해서 중요한 정보가 유출되지 않도록 보호합니다.
3. 네트워크 성능 향상
방화벽은 네트워크를 보호하는 중요한 역할을 하지만, 잘못 구성하면 네트워크의 성능을 떨어뜨릴 수 있습니다. 따라서, 올바르게 구성된 방화벽은 네트워크의 안전성을 유지하면서도 성능을 향상시킬 수 있습니다.

따라서, 방화벽은 네트워크 보안을 강화하고, 데이터 유출을 방지하며, 네트워크 성능을 향상시키기 위해 필요합니다.

### 방화벽의 패킷필터링 방식을 설명해주세요.

패킷 필터링은 방화벽이 패킷의 헤더 정보를 확인하고, 이를 기반으로 패킷을 차단 또는 전달하는 기술입니다. 패킷이란 네트워크 상에서 전송되는 데이터의 단위로, IP 주소, 포트 번호 등의 정보를 가지고 있습니다.

패킷 필터링 방식에는 두 가지가 있습니다.

1. 인바운드 필터링
인바운드 필터링은 외부에서 내부로 들어오는 패킷을 검사하는 방식입니다. 외부에서 내부로 들어오는 모든 패킷을 검사하고, 내부 네트워크에 접근할 수 있는 패킷만을 허용합니다. 이를 통해 내부 네트워크를 외부로부터 보호할 수 있습니다.
2. 아웃바운드 필터링
아웃바운드 필터링은 내부에서 외부로 나가는 패킷을 검사하는 방식입니다. 내부 네트워크에서 발생하는 모든 패킷을 검사하고, 외부 네트워크에 전송될 수 있는 패킷만을 허용합니다. 이를 통해 내부에서 발생한 데이터 유출을 방지할 수 있습니다.

패킷 필터링 방식은 패킷의 헤더 정보를 기반으로 하기 때문에 **IP 주소, 포트 번호 등의 정보를 사용**하여 패킷을 차단하거나 전달합니다. 

예를 들어, 내부 네트워크에서 웹 서버로의 HTTP 요청을 전송할 때, 방화벽은 이 요청의 IP 주소와 포트 번호를 확인하여, 외부에서 내부로의 불법적인 접근을 차단하고, 내부에서 외부로의 데이터 유출을 방지할 수 있습니다.

패킷 필터링은 기본적인 보안 기술 중 하나이며, 네트워크 보안을 강화하는 데 매우 중요한 역할을 합니다.

## 그럼 IP 주소를 바꿔서 접근하면 어떡해?

이러한 상황을 방지하기 위해, 패킷 필터링 방식 외에도 다양한 보안 기술을 함께 사용하게 됩니다. 

예를 들어, 인트라넷이나 VPN을 사용하여 내부 네트워크에 접근하는 사용자를 제한하고, 침입 탐지 시스템(IDS)이나 침입 차단 시스템(IPS) 등의 보안 장비를 함께 사용하여 공격을 탐지하고 방어할 수 있습니다.

또한, 보안 정책을 엄격하게 적용하여, 내부에서 외부로의 데이터 유출을 방지하고, 외부에서 내부로의 불법적인 접근을 차단하는 등의 방법을 사용하여 보안 수준을 높일 수 있습니다. 

따라서, 패킷 필터링은 네트워크 보안을 강화하는 기본적인 보안 기술 중 하나이며, 다양한 보안 기술과 함께 사용되어야 합니다.

### 방화벽으로 막을 수 없는 공격이 있나요?

네. 

방화벽은 패킷 흐름의 시점과 종점을 보고 통과시킬지, 차단할지 판단하는 데, 시점과 종점만 보고 위험한 패킷을 전부 차단할 수 없습니다.

왜냐하면 데이터 송수신중에 헤더는 살피지만 데이터 내용은 살피지 않습니다. 

따라서 이 데이터에 불법적인 해킹 데이터가 포함되어 있어도 신경쓰지 않고 패킷을 통과시키기 때문에 이 패킷이 웹서버에 도착하면 웹서버는 다운됩니다.

- 그럼 어떻게 해결해야하나요?
    
    두가지 방법이 있습니다.
    
    1. 패킷의 내용을 조사하여 위험한 데이터가 있으면 패킷을 차단하도록 하는 장치나 소프트웨어를 방화벽과는 별도로 따로 준비한다. (프록시)
    2. 웹서버에 불법메시지로 인해 버그가 생기면 버그를고쳐서 다운되지 않도록한다.
    
    패킷의 내용이 위험한지의 여부는 웹서버에 버그가 생기는지 여부다. 따라서 1번의 방법도 무조건 막는게 아님
    

### 서버 액세스가 증가해 분산 처리를 하려고 한다 어떤 방법들이 있을까요?

### 1. **dns서버에 여러개의 서버 IP 등록후 라운드 로빈 또는 거리순 IP 선택**

→ 라운드 로빈은 거리가 먼 서버에 접속할 수 있음

→ dns서버에 등록후 거리에 따라 가까운 서버가 접속되도록 세부 설정

→ 거리순은 하누서버에 부하가 올 수 잇으나 그것도 알고리즘 잘 짜보자…

## 2. 로드 밸런서를 dns에 등록

위에서 dns서버에 맡기면 해당하는 서버가 고장났을때도 그 서버를 라운드로빈 또는 거리순으로 알려주면 문제가 발생한다. 왜냐하면 dns 서버는 우리의 서버중 하나가 고장난지 모르기 때문이다.

그래서 **부하 분산 장치** 또는 **로드 밸런서 기기**를 도입했다.

![IMG_3290.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b23ded0-2251-4fa8-a728-d20ef6041b98/IMG_3290.jpeg)

로드밸런서를 웹서버 대신 dns서버에 등록한다. 예를 들어 로드밸런서를 웹 서버에 대응 시켜 www.[google.com](http://google.com)  같은 이름을 붙이고, 그 이름에 대응 하는 IP를 dns서버에 등록한다.

그러면 클라이언트는 로드 밸런서에 요청을 보내고,

로드 밸런서는 우리의 웹 서버와 정기적으로 정보를 교환하여 각 서버의 CPU나 메모리 사용율 등을 고려하여 부하가 낮은 서버에 요청을 전송한다.

### 3. **캐시 서버를 사용한다. (프록시)**

캐시 서버를 dns에 등록해서 서버의 부하를 분산시킬 수 있다.

이때 캐시 서버는 `프록시`라는 구조를 사용하여 데이터를 캐시에 저장하는 서버다.

프록시는 웹 서버와 클라이언트 사이에서 웹 서버에 대한 액세스 동작을 중개한다. 

액세스 동작을 중개할 때 웹 서버에서 받은 데이터를 디스크에 저장해 두고 웹 서버를 대신하여 데이터를 클라이언트에 반송하는 기능을 가지고 있다. 이것을 `캐시`라고 하고, 캐시 서버는 이 기능을 이용한다.

캐시 서버를 경유한 경우 `Via`라는 헤더 필드를 추가하여 웹 서버에 요청.

## 여러대의 웹 서버가 있을때 고려해야할 점 & 서버가 이전 정보를 어떻게 기억할까

우선 HTTP 기본 동작은 요청 메시지를 보내기전에 TCP 접속을 하고, 응답 메시지를 반송하면 연결을 끊는다. 이때 기다리는 시간은 길어야 몇초다.

이때 여러대의 서버가 있을때 생기는 문제가 있다.예를 들어, 회원가입창을 들어가서 이름, 아이디, 비밀번호 등 여러 항목이 대해 입력을 하는 경우 클라이언트와 서버는 접속이 끊긴다.

그리고 사용자는 회원가입 정보를 입력하고 확인을 누르면 웹 서버에 다시 액세스 하는데 TCP 접속 동작부터 다시 시작한다.

그러므로 웹 서버 측에서 보면 HTTP의 대화는 같은 사용자지만 전혀 다른 것으로 본다. 당연하다 HTTP는 무상태성이기 때문에 그렇다.

그럼 웹 서버는 이전 정보를 유지해야 하데 이건 웹서버에 너무 큰 부담이다.

따라서 전후 관계를 판단하기 위해 여러가지 방법이 고안됐다.

그중에 하나는 양식에 입력한 **데이터를 보낼 때 그 안에 전후의 관련을 나타내는 정보를 부가하거나, HTTP헤더에 필드를 부가하는 방법이다.** 이 방법을 `쿠키(cookie)`라고 한다.

로드 밸런서는 이 정보를 조사하여 일련의 동작ㅇ라면 같은 웹 서버에 리퀘스트를 전송하고, 그렇지 않으면 부하가 적은 웹 서버에 전송하도록 동작한다.

## 근데 쿠키 안써도 이전 IP 주소와 비교하면 안되나요?

포워드 프록시를 쓸 경우에는 클라이언트의 IP 주소를 모르기 때문에 사용할 수 없습니다. 그리고 웹 서버가 이 이전 주소를 기다리는 타이머 시간 정보도 유지해야하고 비교해야하므로 웹서버에 부담이 가서 비효율적 입니다.

### 쿠키에 대해 설명해 주세요.

HTTP 특징

- **Connectionless (비연결성)**
- **Stateless (무상태성)**

HTTP 기본 동작은 서버와 클라이언트가 TCP 접속을 하고, 클라이언트가 요청 메시지를 보내면 서버가 응답 메시지를 반송하고, 접속을 끊습니다. 

그리고 HTTP는 연결을 끊으면 상태를 잃는 **무상태성** 이기 때문에, 이전 요청과 응답 간의 정보를 유지할 수 없습니다.

이때 사용자가 로그인 한 경우, 웹 서버는 다음 페이지를 누르더라도 이전에 로그인한 정보를 유지하고 있어야합니다. 이때 웹 서버가 이 정보를 유지하기에는 너무 큰 부담입니다.

그래서 다음 페이지를 누를때 HTTP 헤더에 현재 로그인한 정보를 추가하여 같이 넘겨주는 것을 `쿠키`라고 합니다.

그래서 쿠키는 브라우저에 저장됩니다. 쿠키에는 유지시간이 정해져있어, 시간이 지나면 로그인 기록은 사라지고

유지시간이 지나지 않으면 껐다켜도 브라우저에 정보는 남아있습니다.

### 로그인이 유지 되던데 그건 뭔가요?

쿠키에는 유지시간이 정해져있어, 시간이 지나면 로그인 기록은 사라지고

유지시간이 지나지 않으면 껐다켜도 브라우저에 정보는 남아있습니다.

### 세션에 대해 설명해 주세요.

쿠키는 브라우저, 즉 클라이언트에 웹 이전 정보를 저장했습니다. 

이와 다르게 세션은 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됩니다.

즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 됩니다.

세션의 서버에 저장된 내용을 바탕으로 쿠키를 이용합니다.

쿠키와 가장 큰 차이점은 **사용자의 정보가 저장되는 위치**입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.

**보안**면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.

쿠키도 **만료시간**이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다.

반면에 세션도 만료시간을 정할 수 있지만 **브라우저가 종료되면 만료시간에 상관없이 삭제됩니다**. 예를 들어, 크롬에서 다른 탭을 사용해도 세션은 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있습니다.

[https://dev-coco.tistory.com/61](https://dev-coco.tistory.com/61)

### 포워드 프록시 vs 리버스 프록시

### 캐시 서버

캐시 서버를 dns에 등록해서 서버의 부하를 분산시킬 수 있다.

이때 캐시 서버는 `프록시`라는 구조를 사용하여 데이터를 캐시에 저장하는 서버다.

프록시는 웹 서버와 클라이언트 사이에서 웹 서버에 대한 액세스 동작을 중개한다. 

액세스 동작을 중개할 때 웹 서버에서 받은 데이터를 디스크에 저장해 두고 웹 서버를 대신하여 데이터를 클라이언트에 반송하는 기능을 가지고 있다. 이것을 `캐시`라고 하고, 캐시 서버는 이 기능을 이용한다.

캐시 서버를 경유한 경우 `Via`라는 헤더 필드를 추가하여 웹 서버에 요청.

### 포워드 프록시 캐시

`클라이언트 - 포워드 캐시 - 인터넷 - 서버`

구성으로 클라이언트를 숨겨주고 처음에는 방화벽 역할을 했다.

예를 들어, 사내 망이 있으면 vpn을 켜서 그 vpn에 따라 사내망으로 연결 해준다.

큰 화상이나 영상 같은 대용량 데이터를 포함하는 콘텐츠라면 트래픽이 줄어 효과가 크다.

브라우저에 대한 설정이 꼭 필요하다. 하지만 인터넷에 공개하는 웹 서버는 누가 액세스할 지 알 수 없고, 브라우저에 프록시를 설정할 수 없다.

그래서 브라우저에 프록시를 설정하지 않아도 사용할 수 있도록 개량하여 요청 메시지의 URI에 쓰여 있는 디렉토리명과 전송 대상의로 웹서버를 대응 시켰다. → **리버스 프록시 캐시**

### 리버스 프록시 캐시

`클라이언트 - 인터넷 - 리버스 캐시 - 서버`

구성으로 서버를 숨겨준다.

예를 들어, 클라이언트들이 리버스 프록시에 도착하면 여러대의 서버가 있을 경우, URI에 따라 각각의 서버에 접속시킨다. 클라이언트는 어떤 서버에 접속하는지 모른다.

### 역할

포워드 프록시는 클라이언트 요청을 대신하여 서버에 요청을 보내고, 서버로부터 받은 응답을 캐시에 저장할 수 있습니다. 이렇게 캐시에 저장된 응답은 이후에 동일한 요청이 들어올 경우에는 캐시에서 바로 응답을 반환함으로써, 네트워크 대역폭을 줄이고 웹 페이지 로딩 속도를 향상시킬 수 있습니다.

리버스 프록시는 서버에서 클라이언트로 가는 응답을 캐시에 저장하여, 동일한 요청이 들어올 경우 서버에 요청을 보내지 않고 캐시에서 바로 응답을 반환합니다. 이 역시도 네트워크 대역폭을 줄이고 웹 페이지 로딩 속도를 향상시킬 수 있습니다.

또한, 프록시 서버는 캐시에 저장된 데이터를 이용해 웹 사이트에 대한 접근을 통제할 수 있습니다. 즉, 특정 웹 사이트에 대한 접근을 차단하거나, 특정 웹 사이트의 내용을 필터링할 수 있습니다. 이를 통해 웹 보안을 강화할 수 있습니다.

### 보충

포워드 프록시는 클라이언트가 요청한 내용을 프록시 서버가 받아서 인터넷을 통해 서버로 전달하는 구성입니다. 이를 통해 클라이언트는 직접 서버와 통신하지 않고, 프록시 서버를 통해 간접적으로 통신하게 되어 클라이언트의 IP 주소나 정보 등을 숨길 수 있습니다. 이외에도 포워드 프록시는 요청을 캐싱하여 더 빠른 응답 속도를 제공하거나, 보안성을 강화할 수 있습니다.

리버스 프록시는 클라이언트가 요청한 내용을 프록시 서버에서 받아서 서버측 애플리케이션 서버로 전달하는 구성입니다. 이를 통해 서버측 애플리케이션 서버는 직접 클라이언트와 통신하지 않고, 프록시 서버를 통해 간접적으로 통신하게 됩니다. 이렇게 함으로써 서버의 IP 주소나 정보 등을 숨길 수 있습니다. 또한, 리버스 프록시는 로드 밸런싱, SSL 암호화, 보안 등의 기능을 수행하여 서버의 안정성과 보안성을 강화할 수 있습니다.

추가로, 포워드 프록시와 리버스 프록시는 각각의 역할에 따라 다른 프로토콜을 사용하기도 합니다. 예를 들어, 포워드 프록시는 HTTP, HTTPS, FTP 등을 사용할 수 있고, 리버스 프록시는 HTTP, HTTPS, SMTP 등을 사용할 수 있습니다. 

또한, 포워드 프록시는 클라이언트와 프록시 서버 간의 통신에서만 작동하는 반면, 리버스 프록시는 서버와 프록시 서버 간의 통신에서만 작동합니다.

### 사진 & 트래픽 차이

abc 순서대로

리버스 프록시

포워드 프록시

트랜스 페어런트 프록시

리버스 프록시도 사내 망만 접속 가능한 어플리케이션 인 경우 인터넷을 타지않고 바로 리버스 프록시에서 응답을 받을 수 있다.

![IMG_3294.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c5473aa-d4bc-4aea-95f2-851fe0f201d5/IMG_3294.jpeg)

### 로드 밸런서 vs 리버스 프록시

로드밸런서와 리버스 프록시는 모두 여러 대의 서버에 대한 트래픽을 관리하고 분산시키는 역할을 수행한다는 점에서 유사합니다. 하지만 로드밸런서는 서버의 부하 분산에만 초점을 맞추고, 서버의 요청을 처리하는 데 사용되는 다양한 프로토콜을 지원합니다.

반면에 리버스 프록시는 클라이언트와 서버 간의 통신을 중개하고, 보안 등의 이유로 직접적인 연결을 막기도 합니다. 또한, 리버스 프록시는 주로 웹 서버의 로드밸런싱에 사용되며, 클라이언트의 요청을 받아 적절한 서버에 전달합니다. 이를 통해 클라이언트와 서버 간의 직접적인 통신을 방지하고, 보안과 성능을 향상시킵니다.

따라서, 로드밸런서와 리버스 프록시는 유사한 역할을 수행하지만, 서로 다른 기능과 용도를 가지고 있습니다. 로드밸런서는 주로 서버의 부하 분산에 사용되고, 리버스 프록시는 주로 클라이언트와 서버 간의 통신을 중개하고 보안을 강화하는 데 사용됩니다.

### 트랜스페어런트 프록시

인터넷 주위에 프록시를 두는 방법

포워드, 리버스 프록시는 캐시 서버에 브라우저, URL 대한 웹 서버를 사전에 등록해야 한다.

반면에 트랜스페어런트 프록시는 **요청 메시지에서 패킷의 IP 헤더를 조사하여 액세스 대상 웹 서버를 알아낸다.** 

전송 대상을 캐시 서버에 따로 설정할 필요가 없다. 수신처 IP 주소를 통해 어느 웹 서버에나 전송할 수 있다.

브라우저에서 웹 서버로 요청을 할 때 흘러가는 길에 트랜스페어런트 프록시를 설치하여 그 요청 메시지를 가로채서 찾은 IP 주소에 요청을 보냅니다.

하지만 네트워크가 많기 때문에 네트워크가 모여딘 서브넷의 입구에 하나씩 설치하는 것이 보통입니다.

### 그럼 그 길에 해커가 놓은 프록시를 거치면 어떻게 되나요?

트랜스패어런트 프록시는 일반적으로 클라이언트와 서버 간의 통신 경로를 안전하게 보호하기 위해 사용됩니다. 이러한 프록시는 클라이언트와 서버 간의 모든 통신 데이터를 가로채서 필터링하고, 검사하고, 수정하며, 암호화할 수 있습니다.

그러나 해커가 놓은 프록시를 거친다면, 클라이언트와 서버 간의 통신 데이터가 해커에게 노출될 가능성이 있습니다. 해커가 프록시를 사용하면, 클라이언트와 서버 간의 통신 데이터를 가로채고, 변경하고, 저장할 수 있으며, 악성 코드를 삽입하여 악의적인 목적을 달성할 수도 있습니다.

따라서, 안전한 통신을 위해서는 신뢰할 수 있는 트랜스패어런트 프록시를 사용해야 합니다. 이를 위해서는 안전한 인터넷 연결을 사용하고, 프록시 서버의 인증서를 확인하고, 보안 업데이트가 지속적으로 이루어지는 프록시 서버를 선택해야 합니다. 또한, 중요한 정보를 전송할 때는 암호화된 통신 프로토콜을 사용하여 통신 데이터를 보호해야 합니다.

### 컨텐츠 배포 서비스가 무엇인가요

컨텐츠 배포 서비스(Content Delivery Service, CDS)는 전 세계적으로 사용자들이 원하는 컨텐츠(영상, 음악, 이미지, 문서 등)를 빠르고 안정적으로 전송하는 서비스입니다.

CDS는 컨텐츠를 사용자들이 위치한 지리적 위치에 가까운 서버에 복제하고, 요청이 발생하면 해당 서버에서 컨텐츠를 제공함으로써 빠른 전송 속도와 안정성을 제공합니다.

CDS를 이용하면 다음과 같은 이점이 있습니다.

- 전 세계적으로 높은 대역폭을 보유하고 있는 서버를 사용하여 빠른 다운로드 속도를 제공
- 사용자와 가까운 위치에 위치한 서버를 사용하여 빠른 응답 속도를 제공
- 트래픽 분산 기술을 사용하여 다수의 사용자가 동시에 컨텐츠를 요청해도 안정적으로 서비스를 제공
- 보안 기능을 강화하여 사용자의 개인 정보를 안전하게 보호
- 컨텐츠 관리 기능을 제공하여 사용자가 컨텐츠를 효율적으로 관리할 수 있도록 지원

CDS는 대규모의 컨텐츠 제공 업체, 인터넷 서비스 제공자, 온라인 쇼핑몰 등에서 사용되며, 사용자들이 빠르고 안정적으로 컨텐츠에 접근할 수 있도록 도와줍니다.

### 그냥 캐시 서버를 두면 안되나요?

캐시 서버는 우선 클라이언트와 서버사이에 두는데

리버스 프록시 캐시인 경우에는 인터넷을 거치기 때문에 트래픽이 줄지 않습니다.

그럼 포워드 프록시 캐시는 캐시에 데이터가있으면 인터넷을 안타므로 트래픽이 줄지만 이 캐시를 서버에서 관리할 수 없습니다. 심지어 캐시의 존재여부도 알 수 없습니다.

그래서 트랜스패어런트 프록시 캐시인 인터넷에 캐시를 두는 방법인데 이 방법은 클라이언트와 서버 사이에는 많은 포트 통로가 있는데 이 모든 통로에 캐시를 둬야합니다. 또한 인터넷 어디에서 액세스할 지 알 수 없습니다. 그래서 네트워크가 여러개 모인 서브넷의 입구에 캐시를 두는데 이것도 비용이 만만치 않습니다. 그래서 이 역할을 제공해주는 사업자가 생겼는데, 이 서비스를 CDS 라고 합니다.

### 서버 캐시에 데이터 존재 여부보다, 캐시 내용의 갱신 방법에서 성능 차이가 더 심하게 난다. 그 이유는?

우선 캐시에 데이터가 있는 경우와 데이터가 없는경우로 나뉩니다.

- 캐시에 데이터가 없는 경우
1. 클라이언트는 캐시 서버에 요청
2. 캐시 서버에 데이터가 없으므로 웹서버에 요청
3. 웹서버 응답
4. 웹서버 응답 데이터를 캐시에 저장
5. 클라이언트에 응답

- 캐시에 데이터가 있는 경우
1. 캐시 서버에 요청
2. 캐시에 축적된 데이터가 있으나 바로 응답하지 않음.
3. 웹서버에 현재 캐시에 있는 내용이랑 똑같은지(변하지 않았는지) 확인요청
4. 웹 서버는 변하지 않았음을 응답
5. 캐시서버는 클라이언트에 응답

따라서 결국 캐시 서버에 데이터가 있더라도 웹서버에 있는 데이터와 비교를 해야 한다. 따라서 **웹서버에서 만약 데이터가 바뀌면 캐시에 있는 데이터도 바로 수정해주면 웹 서버와 비교를 하지 않아도 되므로 성능이 빨라진다.**

### 가까운 캐시 서버에 액세스 하는 방법

1.  클라이언트와 캐시서버의 거리를 판단하는 방법
2. 리다이렉트용 서버로 액세스 대상을 분배하는 방법

1.

패킷이 라우터를 거칠때 IP주소와 경로 정보로 캐시 서버와 클라이언트측의 DNS 서버 거리를 조사해서 거리가 짧은 캐시 서버의 정보를 준다.

2.

HTTP에 `Location`헤더가 있다.

이 헤더는 웹 서버의 데이터를 다른 서버로 옮기는 경우에 사용하는 것으로 `그 데이터은 이쪽의 서버에 있으므로 그쪽으로 다시 액세스 하세요.`라는 의미다.

이렇게 다른 웹 서버에 액세스 하도록 처리하는 것을 **리다이렉트(redirect)**라고 한다.

### HTTP 헤더 if-modified-since 헤더가 뭔가요

HTTP 요청 헤더는 조건부 요청으로 서버는 지정된 날짜 이후 수정 된 경우에 `[200](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/200)` 과 함께 요청된 리소스를 돌려 줍니다. 

만약 수정되지 않는 리소스에 대한 요청시, 리소스 없이 `[304](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/304)` 응답을 하게 됩니다.

예를 들어, 캐시 서버 데이터를 웹 서버와 비교해서 값이 다른 경우 이 헤더가(200) 붙고 변경된 데이터가 같이 옵니다.

값이 변경되지 않았다면 이 헤더에 대해 304상태코드를 반환해준다.
